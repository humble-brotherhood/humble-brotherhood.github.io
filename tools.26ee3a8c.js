function e(e){Object.defineProperty(e,"__esModule",{value:!0,configurable:!0})}function o(e,o,n,t){Object.defineProperty(e,o,{get:n,set:t,enumerable:!0,configurable:!0})}var n=("undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:"undefined"!=typeof window?window:"undefined"!=typeof global?global:{}).parcelRequire2d1f;n.register("kGK4j",(function(t,i){e(t.exports),o(t.exports,"default",(()=>s));var a=n("ayMG0"),l=n("2tXDK"),d=n("hzxvt");function s(){let e=l.default;console.log(d);for(const o in d)e+=d[o].default;return(0,a.jsx)("div",{dangerouslySetInnerHTML:{__html:e}})}})),n.register("2tXDK",(function(e,n){o(e.exports,"default",(()=>t));var t='<h1 id="tools">Tools</h1>\n<p>The goal of these tools is to gradually implement things based on logic. The core logic model is hard to understand from scratch (moreover, it is unlikely that you will need full power of it at all).</p>\n<p>Instead, there are set of tutorial that will introduce you all this tools based on things that you already familiar with.</p>\n<h1 id="for-programmers">For programmers</h1>\n'})),n.register("hzxvt",(function(e,o){var t=n("hUNQz"),i=n("jP1XL"),a=n("5oHJq"),l=n("g0mkb"),d=n("kBOWB"),s=n("6eNyF");e.exports={"00-get-started-without-install":t,"01-just-type-what-you-need":i,"02-explore-query-build-plugin":a,"03-dir-lang":l,"06-the-lazy-cache":d,"07-further-learning":s}})),n.register("hUNQz",(function(n,t){e(n.exports),o(n.exports,"default",(()=>i));var i='<h2 id="get-started-without-install">Get started without install</h2>\n<p>This shell script will boostrap <code>stash</code> (that is described bellow) by downloading missed things. This is the easiest way to get started.</p>\n<h3 id="unix">Unix</h3>\n<pre><code class="language-bash">curl https://hb.tools/stash &gt; stash\n</code></pre>\n<blockquote>\n<p>This will do the same in more safe manner. It is not required, but just if you are worried</p>\n<pre><code class="language-bash">curl https://hb.tools/stash --proto &#39;=https&#39; --tlsv1.2 -sSf &gt; stash\n</code></pre>\n</blockquote>\n<h3 id="windows">Windows</h3>\n<p>Type into your powershell</p>\n<pre><code class="language-shell">iwr https://hb.tools/stash\n</code></pre>\n<p>Type <code>./stash</code> to run the shell, or perform <code>stash install</code> to install this script under your PATH and use <code>stash</code> at any directory.</p>\n<p>It is good practice to put this script under your VCS of your project</p>\n'})),n.register("jP1XL",(function(n,t){e(n.exports),o(n.exports,"default",(()=>i));var i='<h2 id="just-type-what-you-need">Just type what you need</h2>\n<p><code>stash</code> shell (Simple Test-Add SHell) will help you to get started and see how our tools can help you.</p>\n<p>Run <code>stash</code> to see short introduction and try to type <code>add</code> or <code>get</code> something.</p>\n<p>Examples:</p>\n<ul>\n<li>Programming<ul>\n<li>Build Web application<ul>\n<li><code>add web application</code><ul>\n<li><code>add typescript</code></li>\n<li><code>add javascript</code></li>\n<li><code>add npm://leftpad</code></li>\n</ul>\n</li>\n<li><code>add web server</code><ul>\n<li><code>add java</code></li>\n<li><code>add kotlin</code></li>\n<li><code>add maven://org.jetbrains.kotlinx/kotlinx-coroutines-core</code> <br>(actually, the right way is <code>add kotlinx://coroutines</code>, see authorities for more details on <code>autoritity://path</code> expressions)</li>\n<li><code>add spring</code></li>\n<li><code>add ktor</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Build Android application<ul>\n<li><code>add android application</code><ul>\n<li><code>add gradle</code></li>\n<li><code>add compose</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Build iOS application<ul>\n<li><code>add ios application</code></li>\n</ul>\n</li>\n<li>Build Desktop application<ul>\n<li><code>add desktop application</code><ul>\n<li><code>add compose</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Build multi-platform application<ul>\n<li><code>add application</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Planning<ul>\n<li><code>add issue</code>, <code>add want</code></li>\n<li><code>add plan</code></li>\n<li><code>add article</code></li>\n<li><code>add blog post</code></li>\n</ul>\n</li>\n<li>Sketching (GUI)<ul>\n<li><code>add figure</code></li>\n<li><code>add diagram</code></li>\n</ul>\n</li>\n</ul>\n'})),n.register("5oHJq",(function(n,t){e(n.exports),o(n.exports,"default",(()=>i));var i='<h2 id="explore-all-the-things">Explore all the things</h2>\n<p><code>explorer</code>, <code>ide</code> and <code>shell</code> will help you to explore what features are available:</p>\n<ul>\n<li><code>shell</code> will help to complete your intention while you are typing</li>\n<li><code>explorer</code> will show you see what deft can <code>get</code>, <code>set</code> or <code>add</code> for your project. Features (and dependencies) are checkboxes — just check what you need.</li>\n<li><code>ide</code> will install Deft plugin into your favorite IDE (not working in this early version of distribution, only dev mode supported — you should run deft from sources)</li>\n</ul>\n<h2 id="querying">Querying</h2>\n<p><code>get npm/version</code> will print kotlin version, and it works with any <code>&lt;expression&gt;</code>.<br><code>get</code> is default command, so just <code>npm/version</code> will do the same.</p>\n<p>You query without adding it: <code>npm://leftpad</code> will show you information about imported maven module.</p>\n<h2 id="how-about-build-and-run">How about build and run?</h2>\n<p>If you already have some programming language and/or framework enabled, just <code>build</code> and <code>run</code>.</p>\n<p>Actually, <code>build &lt;expression&gt;</code> is the same as <code>get &lt;expression&gt;</code>. The only difference is it doesn&#39;t print value to the terminal.</p>\n<p><code>run &lt;expression&gt;</code> is a bit different. Unlike <code>get</code>, <code>run</code> will provide you the <em>process</em> of getting the result (i.e. system process).</p>\n<p>Plugin defines default <code>build</code> and <code>run</code> expressions, that&#39;s why when you have some plugin, just <code>build</code> and <code>run</code> will do what you want. If there is clash between plugins — <code>&lt;expression&gt;</code> is required.</p>\n<h2 id="no-built-ins--everything-is-plugin">No built-ins — everything is plugin</h2>\n<p>Things after <code>add</code>, <code>get</code>, <code>build</code> and <code>run</code> is a Directory language expression. Particularly, reference. <code>kotlin/jvm</code>, <code>compose</code> and even <code>maven</code> are just names of default <em>authority</em>. You can even apply plugins directly from GitHub.</p>\n<p>No builtin things! The core is simple as <a href="https://en.wikipedia.org/wiki/Make_(software)">Make</a>. It just ensures that everything you need is in <code>cache</code> by calling definitions of that things when it is required (or something was changed). The difference is that things are not only files.</p>\n<p>That <code>cache</code> is language and runtime agnostic. Processes reading inputs and writing outputs directly to <em>shared memory</em> using the <code>cache</code> library for particular language and runtime.</p>\n'})),n.register("g0mkb",(function(n,t){e(n.exports),o(n.exports,"default",(()=>i));var i='<h2 id="directory-language">Directory language</h2>\n<p>The language is just list of expressions that you are already familiar with (if you read text above) separated by new line. <code>,</code> can be used instead, optionally.</p>\n<pre><code class="language-dir">web application\ntypescript\nnpm://leftpad\n</code></pre>\n<p>The file can be placed inside directory (<code>something/.dir</code>) or at same level (<code>something.dir</code>). Both defines things for directory with name <code>something</code> (so, the names should not conflict with existing directories and files).</p>\n<p>This syntax can be used to configure features further:</p>\n<pre><code class="language-deft">typescript {\n    module = commonjs\n}\n</code></pre>\n<p>Basic syntax is:</p>\n<ul>\n<li><code>path/to/the/something</code> (or <code>authority://path/to/something</code>)</li>\n<li><code>path/to/the/something { ... }</code></li>\n<li><code>property = value</code>, where value is <code>reference/to/something</code>, <code>&quot;string constant&quot;</code> or number (<code>123</code>).</li>\n</ul>\n<p>Like names of files, names in directory language can contain spaces, but they are normalized (spaces at the start and end of names are ignored, and spaces between words replaced with single space). Use blockquotes (`) to use any character in names (don&#39;t confuse with double and single quotes — they define string constants).</p>\n<p>The language is type safe. You can&#39;t apply incompatible plugins, properties should be defined explicitly, and values should match property type.</p>\n<p>Wonder is that <code>npm://leftpad</code> not in <code>dependnecies { }</code>? Actually both ways work. Module reference acts as dependency by default. Use <code>dependencies { }</code> syntax only for complex configurations or in case of ambiguity.</p>\n<h3 id="templates">Templates</h3>\n<p>First of all, you can define shorthands for lengthy things like <code>maven://..</code> references:</p>\n<pre><code class="language-deft">def kotlinx coroutines = maven://org.jetbrains.kotlinx/kotlinx-coroutines-core\n</code></pre>\n<p>and then use <code>kotlinx-coroutines</code> in your submodules.</p>\n<p>Several expressions can be extracted as <em>template</em>. Comprehensive description is out of scope of this introduction, but here is sample to show the idea:</p>\n<pre><code class="language-deft">def my application = template {\n    def kotlinx coroutines = maven://org.jetbrains.kotlinx/kotlinx-coroutines-core\n    open def kotlin api version: string = &quot;1.6&quot;\n    \n    kotlin/jvm {\n        warnings as errors\n        api-version = kotlin api version\n    }\n    \n    kotlinx-coroutines\n}\n\n// and then, in any module\nmy application\n\n// or\nmy application {\n    kotlin api version = &quot;1.6&quot;\n}\n</code></pre>\n<p>Actually, all plugins <em>are</em> templates. For example <code>kotlin/jvm</code> is complex template, that configures <code>java</code>, <code>kotlin/compiler</code>, <code>kotlin/stdlib</code> dependency and many other things.</p>\n<p>When you need to <em>customize</em>, you are free to override things that <code>kotlin/jvm</code> defines, just like in <code>app-module/kotlin-api-version</code> in the example above. Thought, by default, each <code>def</code> of plugin is final and cannot be customized on template use site. Plugin should explicitly <code>open</code> definitions and restrict allowed values with type (and propositions). Again, let&#39;s leave details for separate post.</p>\n<h3 id="why-new-language">Why new language?</h3>\n<p>There are were many attempts to adopt existing language, but was failed to found something that:</p>\n<ul>\n<li>doesn&#39;t require learning (you already know how to reference files, don&#39;t you?)</li>\n<li>declarative (like <code>json</code>, yes, here is full match)</li>\n<li>type safe (like <code>json</code> with <code>json-schmea</code>, the problem is that too complex for simple things, yet not enough flexible and concise)</li>\n<li>has something like templates that works for simple things and scales up to most complex</li>\n</ul>\n<p>A detailed comparison is beyond the scope of this article, but let me show you the difference by samples of compatibility.</p>\n<h2 id="in-your-favorite-language-and-runtime">In your favorite language and runtime</h2>\n<p>You are free to use all compatible languages together, and they will see declarations of each other.</p>\n<p>Practically, it seems that templates works better for top level configuration, while it is better to define complex logic in programming language (for example: dependency resolution, converting Deft project into IntelliJ and so on).</p>\n'})),n.register("kBOWB",(function(n,t){e(n.exports),o(n.exports,"default",(()=>i));var i='<h2 id="the-lazy-cache">The Lazy Cache</h2>\n<pre><code>&lt;lazy.png&gt;\n</code></pre>\n<p>The hidden fundamental of Deft is lazy object storage.</p>\n<p>Deft never loads all things in memory:</p>\n<ul>\n<li>There is fundamental framework that loads things on demand, while you are walking through the reference, unloading them when more important things is required.</li>\n<li>Project model is defined in way that it never requires full file system scan. File system scanned on demand, while you are walking through the references.</li>\n</ul>\n<p>The next important thing is shared memory, that makes inter process communication mostly zero cost.</p>\n<p>It works concurrently: writers never block reads thanks to copy-on-write strategy.</p>\n<p>You don&#39;t need to bother with all that internals: just define your <code>interface</code> as in <code>AppModule</code> example and Deft will generate code that will deal with shared memory.</p>\n<p>It is reactive, and you don&#39;t need to declare inputs by hand. Deft track what you are reading and remembers that things as inputs. The result of your evaluations will be valid until all inputs remains the same. So, all you need is just to define plugin <code>fun</code> with special <code>@Cached</code> annotation. Deft will cache their result automatically.</p>\n<p>What we have in result? <strong>Deft caches everything, and all updates are precisely incremental</strong>. Not only build artifacts like in classical build systems, but all configuration also. Because there is no difference between configuration and build artifacts. And able to load that caches on demand (never at whole).</p>\n<p>As an example we doesn&#39;t need to manually sync IntelliJ project. All changes are applied on the fly in milliseconds. Because we doesn&#39;t need to rebuild anything.</p>\n'})),n.register("6eNyF",(function(n,t){e(n.exports),o(n.exports,"default",(()=>i));var i=""}));
//# sourceMappingURL=tools.26ee3a8c.js.map
